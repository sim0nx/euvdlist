{
  "id": "EUVD-2025-34987",
  "enisaUuid": "dea0f083-0b6b-36c0-917d-f0edda791d4d",
  "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nthunderbolt: Fix use-after-free in tb_dp_dprx_work\n\nThe original code relies on cancel_delayed_work() in tb_dp_dprx_stop(),\nwhich does not ensure that the delayed work item tunnel->dprx_work has\nfully completed if it was already running. This leads to use-after-free\nscenarios where tb_tunnel is deallocated by tb_tunnel_put(), while\ntunnel->dprx_work remains active and attempts to dereference tb_tunnel\nin tb_dp_dprx_work().\n\nA typical race condition is illustrated below:\n\nCPU 0                            | CPU 1\ntb_dp_tunnel_active()            |\n  tb_deactivate_and_free_tunnel()| tb_dp_dprx_start()\n    tb_tunnel_deactivate()       |   queue_delayed_work()\n      tb_dp_activate()           |\n        tb_dp_dprx_stop()        | tb_dp_dprx_work() //delayed worker\n          cancel_delayed_work()  |\n    tb_tunnel_put(tunnel);       |\n                                 |   tunnel = container_of(...); //UAF\n                                 |   tunnel-> //UAF\n\nReplacing cancel_delayed_work() with cancel_delayed_work_sync() is\nnot feasible as it would introduce a deadlock: both tb_dp_dprx_work()\nand the cleanup path acquire tb->lock, and cancel_delayed_work_sync()\nwould wait indefinitely for the work item that cannot proceed.\n\nInstead, implement proper reference counting:\n- If cancel_delayed_work() returns true (work is pending), we release\n  the reference in the stop function.\n- If it returns false (work is executing or already completed), the\n  reference is released in delayed work function itself.\n\nThis ensures the tb_tunnel remains valid during work item execution\nwhile preventing memory leaks.\n\nThis bug was found by static analysis.",
  "datePublished": "Oct 18, 2025, 9:30:51 AM",
  "dateUpdated": "Oct 18, 2025, 9:30:51 AM",
  "baseScore": 0.0,
  "references": [
    "https://git.kernel.org/stable/c/c07923f6a8729fc27ee652221a51702ff6654097",
    "https://git.kernel.org/stable/c/67600ccfc4f38ebd331b9332ac94717bfbc87ea7",
    "https://nvd.nist.gov/vuln/detail/CVE-2025-40002"
  ],
  "aliases": [
    "CVE-2025-40002"
  ],
  "assigner": "Linux",
  "epss": 0.02,
  "enisaIdProduct": [
    {
      "id": "2351447e-60f1-3efa-ad85-253c13ea98cf",
      "product": {
        "name": "Linux"
      },
      "product_version": "d6d458d42e1e1544a18f37f1d5c840e00d5261b9 <67600ccfc4f38ebd331b9332ac94717bfbc87ea7"
    },
    {
      "id": "3ca65dcc-8cb0-3b71-aad4-f220372dce51",
      "product": {
        "name": "Linux"
      },
      "product_version": "6.14"
    },
    {
      "id": "4e086c17-d1c4-3a3e-b82a-583edb6e8553",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 6.18-rc1"
    },
    {
      "id": "59ff1860-8d2a-300c-8c89-d0f4b06338fd",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 0"
    },
    {
      "id": "8dd29f04-0766-32b6-84dc-daf08e6f4852",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 6.17.3"
    },
    {
      "id": "a392c0d3-53ef-3517-9e52-2b3b0cb0666b",
      "product": {
        "name": "Linux"
      },
      "product_version": "d6d458d42e1e1544a18f37f1d5c840e00d5261b9 <c07923f6a8729fc27ee652221a51702ff6654097"
    }
  ],
  "enisaIdVendor": [
    {
      "id": "0a1cec6f-4436-37d6-b8a4-2a2fa54a2d11",
      "vendor": {
        "name": "Linux"
      }
    }
  ]
}