{
  "id": "EUVD-2025-20060",
  "enisaUuid": "e5de95d7-ced5-3281-8dc9-03522883c01f",
  "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring/rsrc: validate buffer count with offset for cloning\n\nsyzbot reports that it can trigger a WARN_ON() for kmalloc() attempt\nthat's too big:\n\nWARNING: CPU: 0 PID: 6488 at mm/slub.c:5024 __kvmalloc_node_noprof+0x520/0x640 mm/slub.c:5024\nModules linked in:\nCPU: 0 UID: 0 PID: 6488 Comm: syz-executor312 Not tainted 6.15.0-rc7-syzkaller-gd7fa1af5b33e #0 PREEMPT\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\npstate: 20400005 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : __kvmalloc_node_noprof+0x520/0x640 mm/slub.c:5024\nlr : __do_kmalloc_node mm/slub.c:-1 [inline]\nlr : __kvmalloc_node_noprof+0x3b4/0x640 mm/slub.c:5012\nsp : ffff80009cfd7a90\nx29: ffff80009cfd7ac0 x28: ffff0000dd52a120 x27: 0000000000412dc0\nx26: 0000000000000178 x25: ffff7000139faf70 x24: 0000000000000000\nx23: ffff800082f4cea8 x22: 00000000ffffffff x21: 000000010cd004a8\nx20: ffff0000d75816c0 x19: ffff0000dd52a000 x18: 00000000ffffffff\nx17: ffff800092f39000 x16: ffff80008adbe9e4 x15: 0000000000000005\nx14: 1ffff000139faf1c x13: 0000000000000000 x12: 0000000000000000\nx11: ffff7000139faf21 x10: 0000000000000003 x9 : ffff80008f27b938\nx8 : 0000000000000002 x7 : 0000000000000000 x6 : 0000000000000000\nx5 : 00000000ffffffff x4 : 0000000000400dc0 x3 : 0000000200000000\nx2 : 000000010cd004a8 x1 : ffff80008b3ebc40 x0 : 0000000000000001\nCall trace:\n __kvmalloc_node_noprof+0x520/0x640 mm/slub.c:5024 (P)\n kvmalloc_array_node_noprof include/linux/slab.h:1065 [inline]\n io_rsrc_data_alloc io_uring/rsrc.c:206 [inline]\n io_clone_buffers io_uring/rsrc.c:1178 [inline]\n io_register_clone_buffers+0x484/0xa14 io_uring/rsrc.c:1287\n __io_uring_register io_uring/register.c:815 [inline]\n __do_sys_io_uring_register io_uring/register.c:926 [inline]\n __se_sys_io_uring_register io_uring/register.c:903 [inline]\n __arm64_sys_io_uring_register+0x42c/0xea8 io_uring/register.c:903\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151\n el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786\n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600\n\nwhich is due to offset + buffer_count being too large. The registration\ncode checks only the total count of buffers, but given that the indexing\nis an array, it should also check offset + count. That can't exceed\nIORING_MAX_REG_BUFFERS either, as there's no way to reach buffers beyond\nthat limit.\n\nThere's no issue with registrering a table this large, outside of the\nfact that it's pointless to register buffers that cannot be reached, and\nthat it can trigger this kmalloc() warning for attempting an allocation\nthat is too large.",
  "datePublished": "Jul 4, 2025, 1:37:19 PM",
  "dateUpdated": "Jul 28, 2025, 4:14:49 AM",
  "baseScore": 0.0,
  "references": [
    "https://git.kernel.org/stable/c/0e23ac818f3afb16660b0ba384875d56a7013879",
    "https://git.kernel.org/stable/c/1d27f11bf02b38c431e49a17dee5c10a2b4c2e28"
  ],
  "aliases": [
    "CVE-2025-38196"
  ],
  "assigner": "Linux",
  "epss": 0.03,
  "enisaIdProduct": [
    {
      "id": "2a539ae3-e76f-39e1-b749-1f1a49f3189f",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 6.15.4"
    },
    {
      "id": "5fdb93d7-eb28-37fe-93e1-937bb87f6407",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 0"
    },
    {
      "id": "910ec7f8-c71b-37d7-b4f7-a9d3d3b14b65",
      "product": {
        "name": "Linux"
      },
      "product_version": "b16e920a1909da6799c43000db730d8fcdcae907 <1d27f11bf02b38c431e49a17dee5c10a2b4c2e28"
    },
    {
      "id": "a06db37f-4351-37e2-bda4-1e7eb1587666",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 6.16"
    },
    {
      "id": "a5e5c371-a7fd-34d5-a48e-4f0df59fec76",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 6.16-rc3"
    },
    {
      "id": "bfed8967-8b0a-3c31-8c5b-88bf9e307a83",
      "product": {
        "name": "Linux"
      },
      "product_version": "b16e920a1909da6799c43000db730d8fcdcae907 <0e23ac818f3afb16660b0ba384875d56a7013879"
    },
    {
      "id": "fc615698-dac8-33b8-81a0-24d8067a49a1",
      "product": {
        "name": "Linux"
      },
      "product_version": "6.13"
    }
  ],
  "enisaIdVendor": [
    {
      "id": "87a27262-8d74-3b8f-8c69-9f3bdf1ad222",
      "vendor": {
        "name": "Linux"
      }
    }
  ]
}