{
  "id": "EUVD-2026-5907",
  "enisaUuid": "5bbc3ba0-71ca-3d81-81e7-6f9ca7b4eb43",
  "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: fix dead lock while flushing management frames\n\nCommit [1] converted the management transmission work item into a\nwiphy work. Since a wiphy work can only run under wiphy lock\nprotection, a race condition happens in below scenario:\n\n1. a management frame is queued for transmission.\n2. ath12k_mac_op_flush() gets called to flush pending frames associated\n   with the hardware (i.e, vif being NULL). Then in ath12k_mac_flush()\n   the process waits for the transmission done.\n3. Since wiphy lock has been taken by the flush process, the transmission\n   work item has no chance to run, hence the dead lock.\n\n>From user view, this dead lock results in below issue:\n\n wlp8s0: authenticate with xxxxxx (local address=xxxxxx)\n wlp8s0: send auth to xxxxxx (try 1/3)\n wlp8s0: authenticate with xxxxxx (local address=xxxxxx)\n wlp8s0: send auth to xxxxxx (try 1/3)\n wlp8s0: authenticated\n wlp8s0: associate with xxxxxx (try 1/3)\n wlp8s0: aborting association with xxxxxx by local choice (Reason: 3=DEAUTH_LEAVING)\n ath12k_pci 0000:08:00.0: failed to flush mgmt transmit queue, mgmt pkts pending 1\n\nThe dead lock can be avoided by invoking wiphy_work_flush() to proactively\nrun the queued work item. Note actually it is already present in\nath12k_mac_op_flush(), however it does not protect the case where vif\nbeing NULL. Hence move it ahead to cover this case as well.\n\nTested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.1.c5-00302-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1.115823.3",
  "datePublished": "Feb 14, 2026, 3:09:58 PM",
  "dateUpdated": "Feb 14, 2026, 3:09:58 PM",
  "baseScore": 0.0,
  "references": [
    "https://git.kernel.org/stable/c/06ac2aa13f701a0296e92f5f54ae24224d426b28",
    "https://git.kernel.org/stable/c/f88e9fc30a261d63946ddc6cc6a33405e6aa27c3"
  ],
  "aliases": [
    "CVE-2026-23130"
  ],
  "assigner": "Linux",
  "epss": 0.0,
  "enisaIdProduct": [
    {
      "id": "7fb82e22-fb77-4d88-9d43-7b34b5b1c47d",
      "product": {
        "name": "Linux"
      },
      "product_version": "6.14"
    },
    {
      "id": "84677412-52a5-49f3-a94c-aa4e93205f20",
      "product": {
        "name": "Linux"
      },
      "product_version": "56dcbf0b520796e26b2bbe5686bdd305ad924954 <f88e9fc30a261d63946ddc6cc6a33405e6aa27c3"
    },
    {
      "id": "aa5bb2dc-925c-4af8-982d-4c13d1c086e4",
      "product": {
        "name": "Linux"
      },
      "product_version": "56dcbf0b520796e26b2bbe5686bdd305ad924954 <06ac2aa13f701a0296e92f5f54ae24224d426b28"
    },
    {
      "id": "bc74fc88-c3aa-4571-872f-58814ed01838",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 6.19"
    },
    {
      "id": "cba9c208-0724-4bbf-a3bc-24c280ed94e4",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 0"
    },
    {
      "id": "cd9fd780-07d2-4e3a-99f0-b7fc62fb486a",
      "product": {
        "name": "Linux"
      },
      "product_version": "patch: 6.18.8"
    }
  ],
  "enisaIdVendor": [
    {
      "id": "192e37ee-5b5a-4e22-a492-baa592cdce6c",
      "vendor": {
        "name": "Linux"
      }
    }
  ]
}